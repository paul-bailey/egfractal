.. -*- rst -*-

.. : vim: set syntax=rst :

=========
egfractal
=========

--------------------------------------------------
Command-line tools for auto-generating fractal art
--------------------------------------------------

:Author: Paul Bailey <roscidcup@falstaffandme.com>
:Date: December 2018

**egfractal** is my blanket term for source code I use
for generating fractal art.
The “eg” part stands for “evil genius.”
I added it to reduce confusion with other software
with “fractal” in its name;
it was not intended as some sort of impudent proprietary claim.

**TODO** Change names of ``mandelbrot``, ``buddhabrot1``,
``mbrot2``, ``julia1``, and ``bbrot2``, to be consistent
with each other and to not have names that'll liley conflict
with someone else's programs.

Licensing
---------

See COPYING in this directory.

Portability
-----------

I am making this public in the hopes that it may be useful,
but since it works well enough on my systems
(Ubuntu 18.04 and Cygwin on Windows 10)
I do not test it much for portability.
I try to make at least the C code be as generally POSIXive as possible,
though I do use some Gnu-specifics like ``getopt_long`` and such.

You need POSIX threads (``<pthread.h>``) to be supported on your
system for ``mbrot2`` and  ``bbrot2`` to be multi-threaded.  Otherwise
they will run on only one CPU.

Optimizations
-------------

``mbrot2`` and ``bbrot2`` use POSIX threads to split up the
workload over different parts of the image to render.  By
default, four threads are created.  To use more or less, use
the ``--nthread`` option.  I assume that for this to be useful
you need more *cores* than the number of threads --
hyperthreading isn't very useful,
since the only system resource being used is RAM;
no system calls are being made
during the big-long-multi-threaded-algorithm part of the programs.

**TODO**: Run an actual physical test of the above statement
on a hyperthread-able machine and update this README.

``mbrot2`` splits up the workload by selecting different parts
of the image to render for different threads.  Since ``bbrot2``
"traces the path," it splits up the workload by selecting
different starting points of the image to render for different
threads.

This was not written for MSDN.
Frankly I can’t even figure out
how to create a new C-language project on MSDN anymore.
(C++ is *not* C, you meathead!)

.. warning::

   If your system supports pthreads but does not actually
   split the threads between different CPUs, you will
   probably actually **lose** a little performance, due
   to the added overhead of context switching.  In such
   a case, you should explicitly use ``--nthread=1``.

See :doc:`How It Works <how-it-works.txt>` for
the nerdier details of how it all works.

System Requirements
-------------------

All you really need is a Unix-like environment and probably the Gnu
version of libc.

For best performance, use a machine with enough RAM for the program to
allocate without having to swap.  How much RAM does the software use?
It depends mainly on the dimensions of the image you are generating.  For
example, in ``bbrot2``, each RGB channel has an array of
``unsigned long``’s whose length is the number of pixels, in addition to
a similar array of ``long double`` (quad double, depending on compiler)...
times the number of threads plus one...  in addition to a few other arrays.
For a large 6000x6000 bitmap, a program could take up to two or three
hundred megabytes of RAM per thread.

Building
--------

To create the ``configure`` script, you first need to run

::

        $ autoreconf -i

This requires you to have **autotools** and **libtool**
installed on your computer.
After that, run the conventional chain of commands:

::

        $ ./configure
        $ make

Since you are building programs with simple names like ``mbrot2``,
``julia1``, etc.,
which could cause namespace issues with other programs in your path
that have the same name,
I do NOT recommend using ``make install``.
Instead just run the programs in the local directories using specified paths
on the command line.

:TODO: Rename these programs so this isn’t an issue.

Using the Programs
------------------

:TODO: Write ``man`` pages and mention them here.

Known Bugs
----------

The algorithms for equalization are very rudimentary.
Also, something about the distance-to-color selection isn't very
scalable when changing the ``-h`` and ``-w`` options for what is
otherwise the same image tend to result in images fading out as
they get bigger, and statistical outliers are more pronounced when
the images get smaller (perhaps because a single pixel is given
more importance in smaller images, resulting in sophisticated
surfaces losing their subtlety).

Basically, once you find the image you want to render, it's
best to turn off any equalization option and just render it
as-is, then fix it up in a program like Photoshop.

Gallery
-------

All of the following images were auto-generated by the
programs in **egfractal** without any additional processing
(Photoshop or whatnot).

Mandelbrot Images
~~~~~~~~~~~~~~~~~

.. figure:: png/readme-10.png
        :width: 3in
.. figure:: png/readme-15.png
        :width: 3in
.. figure:: png/readme-16.png
        :width: 3in
.. figure:: png/readme-17.png
        :width: 3in
.. figure:: png/readme-18.png
        :width: 3in
.. figure:: png/readme-19.png
        :width: 3in
.. figure:: png/readme-20.png
        :width: 3in

Buddhabrot Images
~~~~~~~~~~~~~~~~~

.. figure:: png/readme-1.png
        :width: 3in

        ``buddhabrot1 -p50000000 -w300 -h300``
.. figure:: png/readme-2.png
        :width: 3in

        ``buddhabrot1 --xline 0.0 -w300 -h300 --equalize=20.0``

.. figure:: png/readme-3.png
        :width: 3in

        ``buddhabrot1 --xline 0.1 -w300 -h300``
.. figure:: png/readme-4.png
        :width: 3in

        ``buddhabrot1 --yline 0.1 -w300 -h300``

.. figure:: png/readme-5.png
        :width: 3in

        ``buddhabrot1 --yline 0.1 -w300 -h300 --equalize=20.0``

.. figure:: png/readme-6.png
        :width: 3in

        ``buddhabrot1 -s -r5000 -m4000 -w300 -h300 -p10000000 --equalize=10.0``

.. figure:: png/readme-7.png
        :width: 3in

        ``buddhabrot1 -s -r5000 -m4000 -w300 -h300 -p10000000 --equalize=10.0 --negate``

        Note that this image is *not* the exact color inverse of the previous.
        That is because at this random-sample/pixel density,
        the final generated image itself has a modicum of randomness too.

        Unfortunately this randomness doesn't scale up very well.
