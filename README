.. -*- rst -*-

.. : vim: set syntax=rst :

=========
egfractal
=========

--------------------------------------------------
Command-line tools for auto-generating fractal art
--------------------------------------------------

:Author: Paul Bailey <roscidcup@falstaffandme.com>
:Date: December 2018

**egfractal** is my blanket term for source code I use
for generating fractal art.
The “eg” part stands for “evil genius.”
I added it to reduce confusion with other software
with “fractal” in its name;
it was not intended as some sort of impudent proprietary claim.

Licensing
---------

See COPYING in this directory.

Portability
-----------

I am making this public in the hopes that it may be useful,
but since it works well enough on my systems
(Ubuntu 18.04 and Cygwin on Windows 10)
I do not test it much for portability.
I try to make at least the C code be as generally POSIXive as possible,
though I do use some Gnu-specifics like ``getopt_long`` and such.

You need POSIX threads (``<pthread.h>``) to be supported on your
system to build ``mbrot2`` and  ``bbrot2``.  The only difference
between these and their non-pthreads counterparts is in the speed
at which they render if run on a multi-core system, and in that
they no longer do anything for the ``--verbose`` argument.

Optimizations
-------------

``mbrot2`` and ``bbrot2`` use POSIX threads to split up the
workload over different parts of the image to render.  By
default, four threads are created.  To use more or less, use
the ``--nthread`` option.  I assume that for this to be useful
you need more *cores* than the number of threads --
hyperthreading isn't very useful,
since the only system resource being used is RAM
(**TODO**: run an actual physical test of this on a
hyperthreaded system); no system calls are being made
during the big-long-multi-threaded-algorithm part of the programs.

``mbrot2`` splits up the workload by selecting different parts
of the image to render for different threads.  Since ``bbrot2``
"traces the path," it splits up the workload by selecting
different starting points of the image to render for different
threads.

This was not written for MSDN.
Frankly I can’t even figure out
how to create a new C-language project on MSDN anymore.
(C++ is *not* C, you meathead!)

System Requirements
-------------------

All you really need is a Unix-like environment and probably the Gnu
version of libc.

For best performance, use a machine with enough RAM for the program to
allocate without having to swap.  How much RAM does the software use?
It depends mainly on the dimensions of the image you are generating.  For
example, in ``buddhabrot1``, each RGB channel has an array of
``unsigned long``’s whose length is the number of pixels, in addition to
a similar array of ``long double`` (quad double, depending on compiler),
in addition to... a few other arrays.  For a large 6000x6000 bitmap,
a program could take up to two or three hundred megabytes of RAM.

System Requirements for mbrot2 and bbrot2
-----------------------------------------

``mbrot2`` and ``bbrot2`` use POSIX threads to increase execution time.
They take a "--nthread N" option (where N is four if the option
is not provided). Don't use N greater than the number of cores,
or you will lose performance again.  (Hyperthreading isn't very
useful, since the only resource being used during the multi-threaded
part of the program is just large chunks of RAM.)

Also, the amount of RAM used is approximately the amount used
in their non-threaded counterparts (``mandelbrot`` and ``buddhabrot1``)
plus that times the number threads.  So don't use these programs
if you don't have the RAM to prevent swapping, or you're missing
the point.

:TODO: Configure so that these programs are skipped on systems
that don't support ``-lpthread``.  Otherwise the whole source
tree will fail to compile.

Building
--------

To create the ``configure`` script, you first need to run

::

        $ autoreconf -i

This requires you to have **autotools** and **libtool**
installed on your computer.
After that, run the conventional chain of commands:

::

        $ ./configure
        $ make

Since you are building programs with simple names like ``mandelbrot``,
``julia1``, etc.,
which could cause namespace issues with other programs in your path
that have the same name,
I do NOT recommend using ``make install``.
Instead just run the programs in the local directories using specified paths
on the command line.

:TODO: Rename these programs so this isn’t an issue.

Using the Programs
------------------

:TODO: Add ``man`` pages and mention them here.

Gallery
-------

All of the following images were auto-generated by the
programs in **egfractal** without any additional processing
(Photoshop or whatnot).

Mandelbrot Images
~~~~~~~~~~~~~~~~~

.. figure:: png/readme-10.png
        :width: 3in
.. figure:: png/readme-15.png
        :width: 3in
.. figure:: png/readme-16.png
        :width: 3in
.. figure:: png/readme-17.png
        :width: 3in
.. figure:: png/readme-18.png
        :width: 3in
.. figure:: png/readme-19.png
        :width: 3in
.. figure:: png/readme-20.png
        :width: 3in

Buddhabrot Images
~~~~~~~~~~~~~~~~~

.. figure:: png/readme-1.png
        :width: 3in

        ``buddhabrot1 -p50000000 -w300 -h300``
.. figure:: png/readme-2.png
        :width: 3in

        ``buddhabrot1 --xline 0.0 -w300 -h300 --equalize=20.0``

.. figure:: png/readme-3.png
        :width: 3in

        ``buddhabrot1 --xline 0.1 -w300 -h300``
.. figure:: png/readme-4.png
        :width: 3in

        ``buddhabrot1 --yline 0.1 -w300 -h300``

.. figure:: png/readme-5.png
        :width: 3in

        ``buddhabrot1 --yline 0.1 -w300 -h300 --equalize=20.0``

.. figure:: png/readme-6.png
        :width: 3in

        ``buddhabrot1 -s -r5000 -m4000 -w300 -h300 -p10000000 --equalize=10.0``

.. figure:: png/readme-7.png
        :width: 3in

        ``buddhabrot1 -s -r5000 -m4000 -w300 -h300 -p10000000 --equalize=10.0 --negate``

        Note that this image is *not* the exact color inverse of the previous.
        That is because at this random-sample/pixel density,
        the final generated image itself has a modicum of randomness too.

        Unfortunately this randomness doesn't scale up very well.
